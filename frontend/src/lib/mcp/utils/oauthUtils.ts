import { SESSION_KEYS, getServerSpecificKey } from "@/lib/mcp/constants";

// The parsed query parameters returned by the Authorization Server
// representing either a valid authorization_code or an error
// ref: https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-4.1.2
type CallbackParams =
  | {
      successful: true;
      // The authorization code is generated by the authorization server.
      code: string;
    }
  | {
      successful: false;
      // The OAuth 2.1 Error Code.
      // Usually one of:
      //    ```
      //    invalid_request, unauthorized_client, access_denied, unsupported_response_type,
      //    invalid_scope, server_error, temporarily_unavailable
      //    ```
      error: string;
      // Human-readable ASCII text providing additional information, used to assist the
      // developer in understanding the error that occurred.
      error_description: string | null;
      // A URI identifying a human-readable web page with information about the error,
      // used to provide the client developer with additional information about the error.
      error_uri: string | null;
    };

/**
 * Parses OAuth 2.1 callback parameters from a URL search string
 * @param location The URL search string (e.g., "?code=abc123" or "?error=access_denied")
 * @returns Parsed callback parameters with success/error information
 */
export const parseOAuthCallbackParams = (location: string): CallbackParams => {
  const params = new URLSearchParams(location);

  const code = params.get("code");
  if (code) {
    return { successful: true, code };
  }

  const error = params.get("error");
  const error_description = params.get("error_description");
  const error_uri = params.get("error_uri");

  if (error) {
    return { successful: false, error, error_description, error_uri };
  }

  return {
    successful: false,
    error: "invalid_request",
    error_description: "Missing code or error in response",
    error_uri: null,
  };
};

/**
 * Generate a random state for the OAuth 2.0 flow.
 *
 * @returns A random state for the OAuth 2.0 flow.
 */
export const generateOAuthState = () => {
  // Generate a random state
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join(
    "",
  );
};

/**
 * Generates a human-readable error description from OAuth callback error parameters
 * @param params OAuth error callback parameters containing error details
 * @returns Formatted multiline error message with error code, description, and optional URI
 */
export const generateOAuthErrorDescription = (
  params: Extract<CallbackParams, { successful: false }>,
): string => {
  const error = params.error;
  const errorDescription = params.error_description;
  const errorUri = params.error_uri;

  return [
    `Error: ${error}.`,
    errorDescription ? `Details: ${errorDescription}.` : "",
    errorUri ? `More info: ${errorUri}.` : "",
  ]
    .filter(Boolean)
    .join("\n");
};

/**
 * Waits for an OAuth token to appear in localStorage after OAuth flow is triggered
 * @param serverUrl The MCP server URL used to construct the token key
 * @param maxWaitTime Maximum time to wait in milliseconds (default: 30000)
 * @param checkInterval Interval between checks in milliseconds (default: 200)
 * @returns Promise that resolves when token is found, or rejects on timeout
 */
export const waitForOAuthToken = (
  serverUrl: string,
  maxWaitTime: number = 30000,
  checkInterval: number = 200,
): Promise<void> => {
  return new Promise((resolve, reject) => {
    if (!serverUrl) {
      reject(new Error("Server URL is required to wait for OAuth token"));
      return;
    }

    const tokenKey = getServerSpecificKey(SESSION_KEYS.TOKENS, serverUrl);
    const startTime = Date.now();

    const checkForToken = () => {
      const token = localStorage.getItem(tokenKey);
      if (token) {
        resolve();
        return;
      }

      if (Date.now() - startTime > maxWaitTime) {
        reject(new Error("OAuth authorization timed out. Please try again."));
        return;
      }

      setTimeout(checkForToken, checkInterval);
    };

    checkForToken();
  });
};
