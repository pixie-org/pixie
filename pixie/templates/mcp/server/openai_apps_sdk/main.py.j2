from __future__ import annotations

from typing import Any, List

from fastmcp import FastMCP
from mcp import types
from mcp.types import Tool as McpTool

{{ pixie_sdk_import }}

mcp_server_name = "{{ server_name }}"

from pydantic import BaseModel, ConfigDict, Field
from typing import Any

def get_widgets() -> list[dict[str, Any]]:
    widgets = []
    {% if tool_functions %}
    {% for tool_func in tool_functions %}
    {{ tool_func }}
    {% endfor %}
    {% endif %}
    return widgets

widgets = get_widgets()

mcp = FastMCP(name=mcp_server_name)

resource_uri_to_widget = {}
for widget in widgets:
    if not widget.get('template_uri'):
        continue
    resource_uri_to_widget[widget['template_uri']] = widget

tool_name_to_widget = {}
for widget in widgets:
    if not widget.get('tool_name'):
        continue
    tool_name_to_widget[widget['tool_name']] = widget

def get_meta(widget: dict[str, Any]) -> dict[str, Any]:
    meta = {
        "openai/outputTemplate": widget.get('template_uri'),
        "openai/toolInvocation/invoking": widget.get('invoking'),
        "openai/toolInvocation/invoked": widget.get('invoked'),
        "openai/widgetAccessible": True,
        "openai/resultCanProduceWidget": True,
        "annotations": {
            "destructiveHint": False,
            "openWorldHint": False,
            "readOnlyHint": True,
        }
    }
    return meta

async def _handle_read_resource(req: types.ReadResourceRequest) -> types.ServerResult:
    resource_uri = str(req.params.uri)
    widget = resource_uri_to_widget.get(resource_uri)
    if widget:
        meta = get_meta(widget)
        contents = [
            types.TextResourceContents(
                uri=widget.get('template_uri'),
                mimeType="text/html+skybridge",
                text=widget.get('html'),
                _meta=meta,
            )
        ]
        return types.ServerResult(types.ReadResourceResult(contents=contents))

    return types.ServerResult(types.ReadResourceResult(_meta={"error": f"Unknown resource: {req.params.uri}"}))

async def _call_tool_request(req: types.CallToolRequest) -> types.ServerResult:
    widget = tool_name_to_widget.get(req.params.name)
    if not widget:
        return types.ServerResult(
            types.CallToolResult(
                content=[
                    types.TextContent(
                        type="text",
                        text=f"Unknown tool: {req.params.name}",
                    )
                ],
                isError=True,
            )
        )
    arguments = req.params.arguments or {}
    if not widget.get('call_tool'):
        return types.ServerResult(
            types.CallToolResult(
                content=[
                    types.TextContent(
                        type="text",
                        text=f"No call tool found for {req.params.name}",
                    )
                ],
                isError=True,
            )
        )
    result = widget.get('call_tool')(**arguments) or {}

    if isinstance(result, dict):
        result = types.CallToolResult(
            content=[
                types.TextContent(
                    type="text",
                    text=result.get('content')[0].text if result.get('content') else "",
                )
            ],
            isError=result.get("error") is not None,
            structuredContent=result.get("structured_content", None),
        )
    return types.ServerResult(
        types.CallToolResult(
            content=[
                types.TextContent(
                    type="text",
                    text=result.content[0].text if result.content else "",
                )
            ],
            isError=result.isError,
            structuredContent=result.structuredContent,
            _meta=get_meta(widget),
        )
    )

@mcp._mcp_server.list_tools()
async def _list_tools() -> List[types.Tool]:
    tools = []
    for widget in widgets:
        tools.append(
        McpTool(
            name=widget.get('tool_name'),
            title=widget.get('title'),
            description=widget.get('resource_description'),
            inputSchema=widget.get('input_schema'),
            _meta=get_meta(widget),
        ))
    return tools

@mcp._mcp_server.list_resources()
async def _list_resources() -> List[types.Resource]:
    resources = []
    for widget in widgets:
        resources.append(
            types.Resource(
                name=widget.get('title'),
                title=widget.get('title'),
                uri=widget.get('template_uri'),
                description=widget.get('resource_description'),
                mimeType="text/html+skybridge",
                _meta=get_meta(widget),
            )
        )
    return resources

@mcp._mcp_server.list_resource_templates()
async def _list_resource_templates() -> List[types.ResourceTemplate]:
    templates = []
    for widget in widgets:
        templates.append(
            types.ResourceTemplate(
            name=widget.get('title'),
            title=widget.get('title'),
            uriTemplate=widget.get('template_uri'),
            description=widget.get('resource_description'),
            mimeType="text/html+skybridge",
            _meta=get_meta(widget),
        )
    )
    return templates

mcp._mcp_server.request_handlers[types.CallToolRequest] = _call_tool_request
mcp._mcp_server.request_handlers[types.ReadResourceRequest] = _handle_read_resource
app = mcp.http_app()

try:
    from starlette.middleware.cors import CORSMiddleware

    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
        allow_credentials=False,
    )
except Exception:  # pragma: no cover - middleware is optional
    print("Failed to add CORS middleware")
    pass

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="0.0.0.0", port=9000)

